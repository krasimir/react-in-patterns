
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Dependency injection Â· React in patterns</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="Krasimir Tsonev">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="./" />
    
    
    <link rel="prev" href="../chapter-09/" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../chapter-01/">
            
                <a href="../chapter-01/">
            
                    
                    In brief
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Foundation</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../chapter-02/">
            
                <a href="../chapter-02/">
            
                    
                    Communication
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.1.1" data-path="../chapter-02/">
            
                <a href="../chapter-02/#input">
            
                    
                    Input
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.2" data-path="../chapter-02/">
            
                <a href="../chapter-02/#output">
            
                    
                    Output
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="../chapter-03/">
            
                <a href="../chapter-03/">
            
                    
                    Event handlers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="../chapter-04/">
            
                <a href="../chapter-04/">
            
                    
                    Composition
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.3.1" data-path="../chapter-04/">
            
                <a href="../chapter-04/#using-reacts-children-api">
            
                    
                    Using React's children API
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.2" data-path="../chapter-04/">
            
                <a href="../chapter-04/#passing-a-child-as-a-prop">
            
                    
                    Passing a child as a prop
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.3" data-path="../chapter-04/">
            
                <a href="../chapter-04/#higher-order-component">
            
                    
                    Higher-order component
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3.4" data-path="../chapter-04/">
            
                <a href="../chapter-04/#function-as-a-children-render-prop">
            
                    
                    Function as a children, render prop
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="2.4" data-path="../chapter-05/">
            
                <a href="../chapter-05/">
            
                    
                    Controlled and uncontrolled inputs
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.5" data-path="../chapter-06/">
            
                <a href="../chapter-06/">
            
                    
                    Presentational and container components
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Data flow</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../chapter-07/">
            
                <a href="../chapter-07/">
            
                    
                    One direction data flow
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="../chapter-08/">
            
                <a href="../chapter-08/">
            
                    
                    Flux
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.2.1" data-path="../chapter-08/">
            
                <a href="../chapter-08/#flux-architecture-and-its-main-characteristics">
            
                    
                    Flux architecture and its main characteristics
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2.2" data-path="../chapter-08/">
            
                <a href="../chapter-08/#implementing-a-flux-architecture">
            
                    
                    Implementing a Flux architecture
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="../chapter-09/">
            
                <a href="../chapter-09/">
            
                    
                    Redux
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.3.1" data-path="../chapter-09/">
            
                <a href="../chapter-09/#redux-architecture-and-its-main-characteristics">
            
                    
                    Redux architecture and its main characteristics
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.3.2" data-path="../chapter-09/">
            
                <a href="../chapter-09/#simple-counter-app-using-redux">
            
                    
                    Simple counter app using Redux
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="header">Good to know</li>
        
        
    
        <li class="chapter active" data-level="4.1" data-path="./">
            
                <a href="./">
            
                    
                    Dependency injection
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.1" data-path="./">
            
                <a href="./#using-reacts-context-prior-v-163">
            
                    
                    Using React's context (prior to v. 16.3)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.2" data-path="./">
            
                <a href="./#using-reacts-context-v-163-and-above">
            
                    
                    Using React's context (v. 16.3 and above)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3" data-path="./">
            
                <a href="./#using-the-module-system">
            
                    
                    Using the module system
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="4.2" data-path="../chapter-11/">
            
                <a href="../chapter-11/">
            
                    
                    Styling
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.2.1" data-path="../chapter-11/">
            
                <a href="../chapter-11/#the-good-old-css-class">
            
                    
                    The good old CSS class
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2.2" data-path="../chapter-11/">
            
                <a href="../chapter-11/#inline-styling">
            
                    
                    Inline styling
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2.3" data-path="../chapter-11/">
            
                <a href="../chapter-11/#css-modules">
            
                    
                    CSS modules
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2.4" data-path="../chapter-11/">
            
                <a href="../chapter-11/#styled-components">
            
                    
                    Styled-components
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="4.3" data-path="../chapter-12/">
            
                <a href="../chapter-12/">
            
                    
                    Integration of third-party libraries
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.4" data-path="../chapter-13/">
            
                <a href="../chapter-13/">
            
                    
                    React and separation of concerns
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Summary</li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="../chapter-14/">
            
                <a href="../chapter-14/">
            
                    
                    Summary
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Dependency injection</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="dependency-injection">Dependency injection</h1>
<p>Many of the modules/components that we write have dependencies. A proper management of these dependencies is critical for the success of the project. There is a technique (most people consider it a <em>pattern</em>) called <a href="http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript" target="_blank"><em>dependency injection</em></a> that helps solving the problem.</p>
<p>In React the need of dependency injector is easily visible. Let&apos;s consider the following application tree:</p>
<pre><code class="lang-js"><span class="hljs-comment">// Title.jsx</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Title</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{ props.title }<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
}

<span class="hljs-comment">// Header.jsx</span>
<span class="hljs-keyword">import</span> Title <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./Title.jsx&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Header</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    &lt;header&gt;
      &lt;Title /&gt;
    &lt;/header&gt;
  );
}

// App.jsx
import Header from &apos;./Header.jsx&apos;;

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = { title: &apos;React in patterns&apos; };
  }
  render() {
    return &lt;Header /&gt;;
  }
};
</code></pre>
<p>The string &quot;React in patterns&quot; should somehow reach the <code>Title</code> component. The direct way of doing this is to pass it from <code>App</code> to <code>Header</code> and then <code>Header</code> pass it down to <code>Title</code>. However, this may work for these three components but what happens if there are multiple properties and deeper nesting. Lots of components will act as proxy passing properties to their children.</p>
<p>We already saw how the <a href="https://krasimir.gitbooks.io/react-in-patterns/content/chapter-04/#higher-order-component" target="_blank">higher-order component</a> may be used to inject data. Let&apos;s use the same technique to inject the <code>title</code> variable:</p>
<pre><code class="lang-js"><span class="hljs-comment">// inject.jsx</span>
<span class="hljs-keyword">const</span> title = <span class="hljs-string">&apos;React in patterns&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inject</span>(<span class="hljs-params">Component</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Injector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    render() {
      <span class="hljs-keyword">return</span> (
        &lt;Component
          {...this.props}
          title={ title }
        /&gt;
      )
    }
  };
}

// -----------------------------------
// Header.jsx
import inject from &apos;./inject.jsx&apos;;
import Title from &apos;./Title.jsx&apos;;

var EnhancedTitle = inject(Title);
export default function Header() {
  return (
    &lt;header&gt;
      &lt;EnhancedTitle /&gt;
    &lt;/header&gt;
  );
}
</code></pre>
<p>The <code>title</code> is hidden in a middle layer (higher-order component) where we pass it as a prop to the original <code>Title</code> component. That&apos;s all nice but it solves only half of the problem. Now we don&apos;t have to pass the <code>title</code> down the tree but how this data reaches the <code>inject.jsx</code> helper.</p>
<h2 id="using-reacts-context-prior-v-163">Using React&apos;s context (prior to v. 16.3)</h2>
<p><em>In v16.3 React&apos;s team introduced a new version of the context API and if you are going to use that version or above you&apos;d probably skip this section.</em></p>
<p>React has the concept of <a href="https://facebook.github.io/react/docs/context.html" target="_blank"><em>context</em></a>. The <em>context</em> is something that every React component has access to. It&apos;s something like an <a href="https://github.com/krasimir/EventBus" target="_blank">event bus</a> but for data. A single <em>store</em> which we access from everywhere.</p>
<pre><code class="lang-js"><span class="hljs-comment">// a place where we will define the context</span>
<span class="hljs-keyword">var</span> context = { title: <span class="hljs-string">&apos;React in patterns&apos;</span> };

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  getChildContext() {
    <span class="hljs-keyword">return</span> context;
  }
  ...
};
App.childContextTypes = {
  title: React.PropTypes.string
};

<span class="hljs-comment">// a place where we use the context</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">var</span> title = <span class="hljs-keyword">this</span>.context.title;
    ...
  }
}
Inject.contextTypes = {
  title: React.PropTypes.string
};
</code></pre>
<p>Notice that we have to specify the exact signature of the context object. With <code>childContextTypes</code> and <code>contextTypes</code>. If those are not specified then the <code>context</code> object will be empty. That can be a little bit frustrating because we may have lots of stuff to put there. That is why it is a good practice that our <code>context</code> is not just a plain object but it has an interface that allows us to store and retrieve data. For example:</p>
<pre><code class="lang-js"><span class="hljs-comment">// dependencies.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  data: {},
  get(key) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.data[key];
  },
  register(key, value) {
    <span class="hljs-keyword">this</span>.data[key] = value;
  }
}
</code></pre>
<p>Then, if we go back to our example, the <code>App</code> component may look like that:</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> dependencies <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./dependencies&apos;</span>;

dependencies.register(<span class="hljs-string">&apos;title&apos;</span>, <span class="hljs-string">&apos;React in patterns&apos;</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  getChildContext() {
    <span class="hljs-keyword">return</span> dependencies;
  }
  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span>;
  }
};
App.childContextTypes = {
  data: React.PropTypes.object,
  get: React.PropTypes.func,
  register: React.PropTypes.func
};
</span></code></pre>
<p>And our <code>Title</code> component gets it&apos;s data through the context:</p>
<pre><code class="lang-js"><span class="hljs-comment">// Title.jsx</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Title</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{ this.context.get(&apos;title&apos;) }<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
  }
}
Title.contextTypes = {
  data: React.PropTypes.object,
  get: React.PropTypes.func,
  register: React.PropTypes.func
};
</code></pre>
<p>Ideally we don&apos;t want to specify the <code>contextTypes</code> every time when we need an access to the context. This detail may be wrapped again in a higher-order component. And even better, we may write an utility function that is more descriptive and helps us declare the exact wiring. I.e instead of accessing the context directly with <code>this.context.get(&apos;title&apos;)</code> we ask the higher-order component to get what we need and pass it as props to our component. For example:</p>
<pre><code class="lang-js"><span class="hljs-comment">// Title.jsx</span>
<span class="hljs-keyword">import</span> wire <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./wire&apos;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Title</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{ props.title }<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> wire(Title, [<span class="hljs-string">&apos;title&apos;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">title</span>) </span>{
  <span class="hljs-keyword">return</span> { title };
});
</code></pre>
<p>The <code>wire</code> function accepts a React component, then an array with all the needed dependencies (which are <code>register</code>ed already) and then a function which I like to call <code>mapper</code>. It receives what is stored in the context as a raw data and returns an object which is later used as props for our component (<code>Title</code>). In this example we just pass what we get - a <code>title</code> string variable. However, in a real app this could be a collection of data stores, configuration or something else.</p>
<p>Here is how the <code>wire</code> function looks like:</p>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wire</span>(<span class="hljs-params">Component, dependencies, mapper</span>) </span>{
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    render() {
      <span class="hljs-keyword">var</span> resolved = dependencies.map(
        <span class="hljs-keyword">this</span>.context.get.bind(<span class="hljs-keyword">this</span>.context)
      );
      <span class="hljs-keyword">var</span> props = mapper(...resolved);

      <span class="hljs-keyword">return</span> React.createElement(Component, props);
    }
  }
  Inject.contextTypes = {
    data: React.PropTypes.object,
    get: React.PropTypes.func,
    register: React.PropTypes.func
  };
  <span class="hljs-keyword">return</span> Inject;
};
</code></pre>
<p><code>Inject</code> is a higher-order component that gets access to the context and retrieves all the items listed under <code>dependencies</code> array. The <code>mapper</code> is a function receiving the <code>context</code> data and transforms it to props for our component.</p>
<h2 id="using-reacts-context-v-163-and-above">Using React&apos;s context (v. 16.3 and above)</h2>
<p>For years the context API was not really recommended by Facebook. They mentioned in the official docs that the API is not stable and may change. And that is exactly what happened. In the version 16.3 we got a new one which I think is more natural and easy to work with.</p>
<p>Let&apos;s use the same example with the string that needs to reach a <code>&lt;Title&gt;</code> component.</p>
<p>We will start by defining a file that will contain our context initialization:</p>
<pre><code class="lang-js"><span class="hljs-comment">// context.js</span>
<span class="hljs-keyword">import</span> { createContext } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;react&apos;</span>;

<span class="hljs-keyword">const</span> Context = createContext({});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Provider = Context.Provider;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Consumer = Context.Consumer;
</code></pre>
<p><code>createContext</code> returns an object that has <code>.Provider</code> and <code>.Consumer</code> properties. Those are actually valid React classes. The <code>Provider</code> accepts our context in the form of a <code>value</code> prop. The consumer is used to access the context and basically read data from it. And because they usually live in different files it is a good idea to create a single place for their initialization. </p>
<p>Let&apos;s say that our <code>App</code> component is the root of our tree. At that place we have to pass the context.</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { Provider } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./context&apos;</span>;

<span class="hljs-keyword">const</span> context = { title: <span class="hljs-string">&apos;React In Patterns&apos;</span> };

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{</span> <span class="hljs-attr">context</span> }&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span>
    );
  }
};
</span></code></pre>
<p>The wrapped components and their children now share the same context. The <code>&lt;Title&gt;</code> component is the one that needs the <code>title</code> string so that is the place where we use the <code>&lt;Consumer&gt;</code>.</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> { Consumer } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./context&apos;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Title</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Consumer</span>&gt;</span>{
      ({ title }) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title: { title }<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    }<span class="hljs-tag">&lt;/<span class="hljs-name">Consumer</span>&gt;</span></span>
  );
}
</code></pre>
<p><em>Notice that the <code>Consumer</code> class uses the function as children (render prop) pattern to deliver the context.</em></p>
<p>The new API feels easier to understand and eliminates the boilerplate. It is still pretty new but looks promising. It opens a whole new range of possibilities.</p>
<h2 id="using-the-module-system">Using the module system</h2>
<p>If we don&apos;t want to use the context there are a couple of other ways to achieve the injection. They are not exactly React specific but worth mentioning. One of them is using the module system.</p>
<p>As we know the typical module system in JavaScript has a caching mechanism. It&apos;s nicely noted in the <a href="https://nodejs.org/api/modules.html#modules_caching" target="_blank">Node&apos;s documentation</a>:</p>
<blockquote>
<p>Modules are cached after the first time they are loaded. This means (among other things) that every call to require(&apos;foo&apos;) will get exactly the same object returned, if it would resolve to the same file.</p>
<p>Multiple calls to require(&apos;foo&apos;) may not cause the module code to be executed multiple times. This is an important feature. With it, &quot;partially done&quot; objects can be returned, thus allowing transitive dependencies to be loaded even when they would cause cycles.</p>
</blockquote>
<p>How is that helping for our injection? Well, if we export an object we are actually exporting a <a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/#singletonpatternjavascript" target="_blank">singleton</a> and every other module that imports the file will get the same object. This allows us to <code>register</code> our dependencies and later <code>fetch</code> them in another file.</p>
<p>Let&apos;s create a new file called <code>di.jsx</code> with the following content:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> dependencies = {};

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">register</span>(<span class="hljs-params">key, dependency</span>) </span>{
  dependencies[key] = dependency;
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetch</span>(<span class="hljs-params">key</span>) </span>{
  <span class="hljs-keyword">if</span> (dependencies[key]) <span class="hljs-keyword">return</span> dependencies[key];
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`&quot;<span class="hljs-subst">${ key }</span> is not registered as dependency.`</span>);
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wire</span>(<span class="hljs-params">Component, deps, mapper</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Injector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>(props) {
      <span class="hljs-keyword">super</span>(props);
      <span class="hljs-keyword">this</span>._resolvedDependencies = mapper(...deps.map(fetch));
    }
    render() {
      <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span>
          {<span class="hljs-attr">...this.state</span>}
          {<span class="hljs-attr">...this.props</span>}
          {<span class="hljs-attr">...this._resolvedDependencies</span>}
        /&gt;</span>
      );
    }
  };
}
</span></code></pre>
<p>We&apos;ll store the dependencies in <code>dependencies</code> global variable (it&apos;s global for our module, not for the whole application). We then export two functions <code>register</code> and <code>fetch</code> that write and read entries. It looks a little bit like implementing setter and getter against a simple JavaScript object. Then we have the <code>wire</code> function that accepts our React component and returns a <a href="https://krasimir.gitbooks.io/react-in-patterns/content/chapter-04/#higher-order-component" target="_blank">higher-order component</a>. In the constructor of that component we are resolving the dependencies and later while rendering the original component we pass them as props. We follow the same pattern where we describe what we need (<code>deps</code> argument) and extract the needed props with a <code>mapper</code> function.</p>
<p>Having the <code>di.jsx</code> helper we are again able to register our dependencies at the entry point of our application (<code>app.jsx</code>) and inject them wherever (<code>Title.jsx</code>) we need.</p>
<p><span class="new-page"></span></p>
<pre><code class="lang-js"><span class="hljs-comment">// app.jsx</span>
<span class="hljs-keyword">import</span> Header <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./Header.jsx&apos;</span>;
<span class="hljs-keyword">import</span> { register } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./di.jsx&apos;</span>;

register(<span class="hljs-string">&apos;my-awesome-title&apos;</span>, <span class="hljs-string">&apos;React in patterns&apos;</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> &lt;Header /&gt;;
  }
};

// -----------------------------------
// Header.jsx
import Title from &apos;./Title.jsx&apos;;

export default function Header() {
  return (
    &lt;header&gt;
      &lt;Title /&gt;
    &lt;/header&gt;
  );
}

// -----------------------------------
// Title.jsx
import { wire } from &apos;./di.jsx&apos;;

var Title = function(props) {
  return &lt;h1&gt;{ props.title }&lt;/h1&gt;;
};

export default wire(
  Title,
  [&apos;my-awesome-title&apos;],
  title =&gt; ({ title })
);
</code></pre>
<p><em>If we look at the <code>Title.jsx</code> file we&apos;ll see that the actual component and the wiring may live in different files. That way the component and the mapper function become easily unit testable.</em></p>
<h2 id="final-thoughts">Final thoughts</h2>
<p>Dependency injection is a tough problem. Especially in JavaScript. Lots of people didn&apos;t realize that but putting a proper dependency management is a key process of every development cycle. JavaScript ecosystem offers different tools and we as developers should pick the one that fits in our needs.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../chapter-09/#simple-counter-app-using-redux" class="navigation navigation-prev " aria-label="Previous page: Simple counter app using Redux">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="./#using-reacts-context-prior-v-163" class="navigation navigation-next " aria-label="Next page: Using React's context (prior to v. 16.3)">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Dependency injection","level":"4.1","depth":1,"next":{"title":"Using React's context (prior to v. 16.3)","level":"4.1.1","depth":2,"anchor":"#using-reacts-context-prior-v-163","path":"chapter-10/README.md","ref":"chapter-10/README.md#using-reacts-context-prior-v-163","articles":[]},"previous":{"title":"Simple counter app using Redux","level":"3.3.2","depth":2,"anchor":"#simple-counter-app-using-redux","path":"chapter-09/README.md","ref":"chapter-09/README.md#simple-counter-app-using-redux","articles":[]},"dir":"ltr"},"config":{"plugins":[],"root":"./book","styles":{"website":"./styles/website.css","ebook":"./styles/ebook.css","pdf":"./styles/ebook.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Krasimir Tsonev","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a5","chapterMark":"pagebreak","pageBreaksBefore":"//*[@class='new-page']","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"React in patterns","gitbook":"3.2.3","description":"A book about common design patterns used while developing with React."},"file":{"path":"chapter-10/README.md","mtime":"2018-10-17T19:02:30.000Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-10-17T19:02:47.735Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

